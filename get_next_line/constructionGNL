Environnement :

GNL doit envoyer une ligne d'un fichier dont le file descriptor est passe en parametre.
Une ligne est definie soit par un '\n' soit par un EOF.

La fonction GNL est appelle depuis une fonction qui aura au prealable ouvert (open) un fichier.
Cette fonction appelle alors GNL en lui passant en parametre le file descriptor du fichier ouvert ainsi que
l'adresse de la chaine ou ecrire le resultat de GNL.

GNL doit retourner respectivement 1, 0 ou -1 selon si une ligne a ete lue('\n'),
si la lecture est terminee (EOF) ou si il y a eu une erreur.

Fonctionnement :

Structure :
-> Declaration des variables
-> Allocation de la memoire a *line et au char**
-> Gestion des cas d'erreur
-> Read du file descriptor
-> Resolution de la foncion
-> Retour et sortie

	Declaration des variables : 
		-> static char** stock;
		-> ssize_t;
		-> ssize_t;

	Allocation memoire :
		Si stock ou stock[] n'existe pas
			|-> fonction d'allocation pour stock puis pour stock[]
		-> free de *line puis nouvelle allocation (ft_strlen(stock[]) + BUFF_SIZE);

	Cas d'erreurs :
		-> fd <= 0;
		-> read = 0;

	Read : 
		-> ssize_t = read(fd, stock[], BUFF_SIZE);
	
	Resolution :
		-> cf description.

	Retour et sortie :
		-> Erreur : return (-1)
		-> Reussite : return (1)
		-> Fin : return (0);

Description de resolution :
	
	En fonction de BUFF_SIZE :

	Situation 1 = read ne lit pas de '\n';
	Situation 2 = read lit un seul '\n';
	Situation 3 = read lit plusieurs '\n';
	

	1) Copier/concatener read dans line puis continuer la lecture jusqu'a arriver a situation 2 ou 3.

	2) Si line existe -> ajouter read a line jusqu'au '\n';
	   Si line n'existe pas -> copier read dans line jusqu'au '\n';
	   --> Stocker le reste de read dans le static char, deplacer le pointeur apres le '\n'

	3) Cas A. = lecture est finie (read = 0)
	   Cas B. = lecture n'est pas finie (read > 0)

	   3)__A) -> stock contient le reste du fichier jusqu'a l'EOF :
	    		 	1) Placer le contenu de stock[] dans line jusqu'a un '\n'.
					2) Modifier le pointeur de stock[] et le deplacer derriere le '\n' (les '\n' si plusieurs consecutifs)
					3) Continuer tant que stock[] existe.
					4) CAS PARTICULIER EOF = Arrive au bout de stock, effacer son contenu et retourner 1.
					
	   3)__B) -> stock contient une partie du fichier mais pas l'EOF :
	   				1) Placer le contenu de stock dans line jusqu'a un '\n'.
					2) Modifier le pointeur de stock[] et le deplacer derriere le '\n' (les '\n' si plusieurs consecutifs)
					3) Continuer tant que stock existe
					4) Lorsque stock arrive au bout, read de nouveau et concatener le resultat a line jusqu'au prochain '\n'..
						!! Ne pas retourner 1 directement! Stock ne finira pas forcement par un '\n' read de nouveaujusqu'a un '\n'  !! 
